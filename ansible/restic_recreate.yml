---
# Manual playbook to recreate locked out restic repositories OR fix desynchronized config files
# Use this if you have lost the password (recreate) or if local config is out of sync (fix)
# Usage: ansible-playbook restic_recreate.yml -i production --limit <hostname>

- name: FIX RESTIC REPOSITORIES AND CONFIGURATION
  hosts: all
  strategy: linear # Required for the pause module
  become: true
  become_user: "{{ create_user }}"
  vars_files:
    - plays/vars/default.yml
    - plays/vars/restic.yml
    - plays/vars/secrets.yml

  tasks:
    # 1. Check Repository Accessibility (Remote)
    - name: Check if repositories are accessible (using Ansible password)
      shell: |
        export RESTIC_REPOSITORY="{{ item.repository }}"
        export RESTIC_PASSWORD="{{ item.password }}"
        restic snapshots >/dev/null 2>&1
      loop:
        - { name: 'home', repository: "{{ restic.home.repository }}", password: "{{ restic.home.password }}" }
        - { name: 'root', repository: "{{ restic.root.repository }}", password: "{{ restic.root.password }}" }
      register: repo_check
      failed_when: false
      changed_when: false

    # 2. Check Local Environment Files (Local)
    - name: Check local environment files content
      slurp:
        src: "/etc/restic/env.{{ item.name }}"
      loop:
        - { name: 'home' }
        - { name: 'root' }
      register: local_env_files
      failed_when: false # File might not exist
      become: true
      become_user: root

    # 3. Analyze State
    - name: Analyze Restic State
      set_fact:
        # Repos that cannot be opened with the CURRENT Ansible password -> Must be recreated
        broken_repos: "{{ repo_check.results | selectattr('rc', 'ne', 0) | map(attribute='item.name') | list }}"
        
        # Files that don't match the CURRENT Ansible password -> Must be updated
        mismatched_files: >-
          {%- set mismatches = [] -%}
          {%- for result in local_env_files.results -%}
            {%- set name = result.item.name -%}
            {%- set expected_pass = (name == 'home') | ternary(restic.home.password, restic.root.password) -%}
            {%- if result['content'] is defined -%}
              {%- set content = result['content'] | b64decode -%}
              {%- set current_pass = content | regex_findall('export RESTIC_PASSWORD="(.*)"') | first | default('') -%}
              {%- if current_pass != expected_pass -%}
                {{- mismatches.append(name) -}}
              {%- endif -%}
            {%- endif -%}
          {%- endfor -%}
          {{ mismatches }}

    - name: Display Status
      debug:
        msg: 
          - "Broken Repositories (Lockout): {{ broken_repos }}"
          - "Mismatched Config Files: {{ mismatched_files }}"

    - name: Fail if everything is fine
      fail:
        msg: "System is healthy. Repositories accessible and local config matches Ansible secrets."
      when: 
        - broken_repos | length == 0
        - mismatched_files | length == 0

    # 4. Confirmation
    - name: "⚠️  WARNING: CONFIRM ACTIONS"
      pause:
        prompt: |
          ACTIONS REQUIRED on {{ inventory_hostname }}:

          {% if broken_repos | length > 0 %}
          [CRITICAL] RECREATE REPOSITORIES (Data Loss):
          - {{ broken_repos | join(', ') }}
          -> Will be WIPED and re-initialized. Backup history LOST.
          {% endif %}

          {% if mismatched_files | length > 0 %}
          [FIX] UPDATE CONFIGURATION FILES:
          - {{ mismatched_files | join(', ') }}
          -> Local file /etc/restic/env.* will be updated to match Ansible secrets.
          {% endif %}

          Are you sure you want to proceed? (yes/no)
      register: pause_result
      when: confirm_recreate | default('') | lower != 'yes'

    - name: Abort if not confirmed
      fail:
        msg: "Aborted."
      when: 
        - not (confirm_recreate | default('') | lower == 'yes')
        - not (pause_result.user_input | default('') | lower == 'yes')

    # 5. Recreate Logic
    - name: Recreate broken repositories
      block:
        - name: Check for local storagebox mount
          stat:
            path: "/mnt/storagebox/backup/{{ inventory_hostname }}"
          register: storagebox_mount

        - name: Delete repository via local mount (Preferred)
          file:
            path: "/mnt/storagebox/backup/{{ inventory_hostname }}/restic-{{ item }}"
            state: absent
          loop: "{{ broken_repos }}"
          when: storagebox_mount.stat.exists and storagebox_mount.stat.writeable
          register: mount_delete

        - name: Delete remote repository directories (SFTP Fallback)
          shell: |
            sftp {{ restic.sftp.host_alias }} <<'EOF' 2>&1
            -rm {{ storagebox_credentials.share }}/{{ inventory_hostname }}/restic-{{ item }}/config
            -rmdir {{ storagebox_credentials.share }}/{{ inventory_hostname }}/restic-{{ item }}/data
            -rmdir {{ storagebox_credentials.share }}/{{ inventory_hostname }}/restic-{{ item }}/index
            -rmdir {{ storagebox_credentials.share }}/{{ inventory_hostname }}/restic-{{ item }}/keys
            -rmdir {{ storagebox_credentials.share }}/{{ inventory_hostname }}/restic-{{ item }}/snapshots
            -rmdir {{ storagebox_credentials.share }}/{{ inventory_hostname }}/restic-{{ item }}
            EOF
          loop: "{{ broken_repos }}"
          when: 
            - "restic[item].repository.startswith('sftp://')"
            - not (mount_delete.results | selectattr('item', 'equalto', item) | map(attribute='changed') | first | default(false))
          register: sftp_delete
          failed_when: false

        - name: Delete local repository directories
          file:
            path: "{{ restic[item].repository }}"
            state: absent
          loop: "{{ broken_repos }}"
          when: "not restic[item].repository.startswith('sftp://')"
          become: true
          become_user: root

        - name: Re-initialize repositories
          shell: |
            export RESTIC_REPOSITORY="{{ item.repository }}"
            export RESTIC_PASSWORD="{{ item.password }}"
            if [[ "{{ item.repository }}" == sftp://* ]]; then
               sftp {{ restic.sftp.host_alias }} <<EOF
               -mkdir {{ storagebox_credentials.share }}/{{ inventory_hostname }}/restic-{{ item.name }}
            EOF
            fi
            restic init
          loop:
            - { name: 'home', repository: "{{ restic.home.repository }}", password: "{{ restic.home.password }}" }
            - { name: 'root', repository: "{{ restic.root.repository }}", password: "{{ restic.root.password }}" }
          vars:
            password: "{{ (item.name == 'home') | ternary(restic.home.password, restic.root.password) }}"
          when: item.name in broken_repos
          register: restic_reinit
          changed_when: "'created restic repository' in restic_reinit.stdout"
          failed_when: 
            - restic_reinit.rc != 0
            - "'config file already exists' not in restic_reinit.stderr"
      when: broken_repos | length > 0

    # 6. Config Fix Logic (Runs for both Recreated AND Mismatched)
    - name: Force update environment files
      template:
        src: plays/roles/user/templates/restic_env.j2
        dest: "/etc/restic/env.{{ item.name }}"
        owner: root
        group: root
        mode: '0644'
      vars:
        env_name: "{{ item.name }}"
        repository: "{{ item.repository }}"
        password: "{{ item.password }}"
      loop:
        - { name: 'home', repository: "{{ restic.home.repository }}", password: "{{ restic.home.password }}" }
        - { name: 'root', repository: "{{ restic.root.repository }}" , password: "{{ restic.root.password }}"}
      # Update if it was broken (recreated) OR if it was mismatched
      when: (item.name in broken_repos) or (item.name in mismatched_files)
      become: true
      become_user: root

    # 7. Populate New Repositories
    - name: Trigger immediate backup to populate new repositories (background)
      systemd:
        scope: user
        name: "restic-backup-{{ item }}.service"
        state: started
        no_block: yes
      loop: "{{ broken_repos }}"
      when: broken_repos | length > 0

    - name: Validate backup is running
      shell: "sleep 2 && XDG_RUNTIME_DIR=/run/user/$(id -u) systemctl --user is-active restic-backup-{{ item }}.service"
      loop: "{{ broken_repos }}"
      when: broken_repos | length > 0
      register: backup_status
      failed_when: "'active' not in backup_status.stdout and 'activating' not in backup_status.stdout"
      changed_when: false